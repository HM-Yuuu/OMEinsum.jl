<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DocStrings · OMEinsum.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>OMEinsum.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../parsing/">Parsing</a></li><li><a class="toctext" href="../implementation/">Implementations</a></li><li><a class="toctext" href="../extending/">Extending OMEinsum</a></li><li class="current"><a class="toctext" href>DocStrings</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>DocStrings</a></li></ul><a class="edit-page" href="https://github.com/under-Peter/OMEinsum.jl/blob/master/docs/src/docstrings.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>DocStrings</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.EinArray" href="#OMEinsum.EinArray"><code>OMEinsum.EinArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">EinArray{T, N, TT, LX, LY, ICT, OCT} &lt;: AbstractArray{T, N}</code></pre><p>A struct to hold the intermediate result of an <code>einsum</code> where all index-labels of both input and output are expanded to a rank-<code>N</code>-array whose values are lazily calculated. Indices are arranged as <em>inner indices</em> (or reduced dimensions) first and <em>then outer indices</em>.</p><p>Type parameters are</p><pre><code class="language-none">* `T`: element type,
* `N`: array dimension,
* `TT`: type of &quot;tuple of input arrays&quot;,
* `LX`: type of &quot;tuple of input indexers&quot;,
* `LX`: type of output indexer,
* `ICT`: typeof inner CartesianIndices,
* `OCT`: typeof outer CartesianIndices,</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/Core.jl#LL57-L74">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.EinCode" href="#OMEinsum.EinCode"><code>OMEinsum.EinCode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">EinCode{ixs, iy}</code></pre><p>Wrapper to <code>eincode</code>-specification that creates a callable object to evaluate the <code>eincode</code> <code>ixs -&gt; iy</code> where <code>ixs</code> are the index-labels of the input-tensors and <code>iy</code> are the index-labels of the output</p><p><strong>example</strong></p><pre><code class="language-julia-repl">julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; EinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)),(&#39;i&#39;,&#39;k&#39;))(a, b) ≈ a * b
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/Core.jl#LL4-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.EinIndexer" href="#OMEinsum.EinIndexer"><code>OMEinsum.EinIndexer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">EinIndexer{locs,N}</code></pre><p>A structure for indexing <code>EinArray</code>s. <code>locs</code> is the index positions (among all indices). In the constructor, <code>size</code> is the size of target tensor,</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/Core.jl#LL26-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.EinIndexer-Union{Tuple{Tuple{Vararg{Int64,N}}}, Tuple{locs}, Tuple{N}} where locs where N" href="#OMEinsum.EinIndexer-Union{Tuple{Tuple{Vararg{Int64,N}}}, Tuple{locs}, Tuple{N}} where locs where N"><code>OMEinsum.EinIndexer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">EinIndexer{locs}(size::Tuple)</code></pre><p>Constructor for <code>EinIndexer</code> for an object of size <code>size</code> where <code>locs</code> are the locations of relevant indices in a larger tuple.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/Core.jl#LL36-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.IndexSize" href="#OMEinsum.IndexSize"><code>OMEinsum.IndexSize</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IndexSize{N,T}(k::NTuple{N,T},v::NTuple{N,Int})</code></pre><p>struct to hold the size of indices specified by their labels. Note that while a dict would work, for the small sizes we usually have, a tuple of keys and values is much faster to construct and competitive for lookup.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/interfaces.jl#LL71-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.einarray-Union{Tuple{TT}, Tuple{NI}, Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs,iy},TT,Any}} where TT&lt;:Tuple{Vararg{AbstractArray,NI}} where NI where iy where ixs" href="#OMEinsum.einarray-Union{Tuple{TT}, Tuple{NI}, Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs,iy},TT,Any}} where TT&lt;:Tuple{Vararg{AbstractArray,NI}} where NI where iy where ixs"><code>OMEinsum.einarray</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">einarray(::EinCode, xs, size_dict) -&gt; EinArray</code></pre><p>Constructor of <code>EinArray</code> from an <code>EinCode</code>, a tuple of tensors <code>xs</code> and a <code>size_dict</code> of type <code>IndexSize</code> that assigns each index-label a size. The returned <code>EinArray</code> holds an intermediate result of the <code>einsum</code> specified by the <code>EinCode</code> with indices corresponding to all unique labels in the einsum. Reduction over the (lazily calculated) dimensions that correspond to labels not present in the output lead to the result of the einsum.</p><p><strong>example</strong></p><pre><code class="language-julia-repl">julia&gt; using OMEinsum: get_size_dict

julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; sd = get_size_dict(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)), (a, b));

julia&gt; ea = OMEinsum.einarray(EinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)),(&#39;i&#39;,&#39;k&#39;)), (a,b), sd);

julia&gt; dropdims(sum(ea, dims=1), dims=1) ≈ a * b
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/Core.jl#LL87-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.einsum-Union{Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs,iy},Any,Any}} where iy where ixs" href="#OMEinsum.einsum-Union{Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs,iy},Any,Any}} where iy where ixs"><code>OMEinsum.einsum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">einsum(::EinCode{ixs, iy}, xs, size_dict) where {ixs, iy}</code></pre><p>return the tensor that results from contracting the tensors <code>xs</code> according to their indices <code>ixs</code>, where all indices that do not appear in the output <code>iy</code> are summed over. The result is permuted according to <code>out</code>.</p><ul><li><p><code>ixs</code> - tuple of tuples of index-labels of the input-tensors <code>xs</code></p></li><li><p><code>iy</code> - tuple of index-labels of the output-tensor</p></li><li><p><code>xs</code> - tuple of tensors</p></li><li><p><code>size_dict</code> - <code>IndexSize</code>-object that maps index-labels to their sizes</p></li></ul><p><strong>example</strong></p><pre><code class="language-julia-repl">julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; einsum(EinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)),(&#39;i&#39;,&#39;k&#39;)), (a, b)) ≈ a * b
true

julia&gt; einsum(EinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)),(&#39;k&#39;,&#39;i&#39;)), (a, b)) ≈ permutedims(a * b, (2,1))
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/einsum.jl#LL3-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.loop_einsum!-Union{Tuple{iy}, Tuple{ixs}, Tuple{IT}, Tuple{T}, Tuple{L}, Tuple{N}, Tuple{EinCode{ixs,iy},Tuple{Vararg{AbstractArray{#s13,M} where #s13 where M,N}},AbstractArray{T,L},Any}} where iy where ixs where IT&lt;:Union{AbstractChar, Integer} where T where L where N" href="#OMEinsum.loop_einsum!-Union{Tuple{iy}, Tuple{ixs}, Tuple{IT}, Tuple{T}, Tuple{L}, Tuple{N}, Tuple{EinCode{ixs,iy},Tuple{Vararg{AbstractArray{#s13,M} where #s13 where M,N}},AbstractArray{T,L},Any}} where iy where ixs where IT&lt;:Union{AbstractChar, Integer} where T where L where N"><code>OMEinsum.loop_einsum!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">loop_einsum!(::EinCode, xs, y, size_dict)</code></pre><p>inplace-version of <code>loop_einsum</code>, saving the result in a preallocated tensor of correct size <code>y</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/loop_einsum.jl#LL17-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.loop_einsum-Union{Tuple{iy}, Tuple{ixs}, Tuple{T}, Tuple{N}, Tuple{EinCode{ixs,iy},Tuple{Vararg{AbstractArray{#s13,M} where #s13 where M,N}},Any}} where iy where ixs where T where N" href="#OMEinsum.loop_einsum-Union{Tuple{iy}, Tuple{ixs}, Tuple{T}, Tuple{N}, Tuple{EinCode{ixs,iy},Tuple{Vararg{AbstractArray{#s13,M} where #s13 where M,N}},Any}} where iy where ixs where T where N"><code>OMEinsum.loop_einsum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">loop_einsum(::EinCode, xs, size_dict)</code></pre><p>evaluates the eincode specified by <code>EinCode</code> and the tensors <code>xs</code> by looping over all possible indices and calculating the contributions ot the result. Scales exponentially in the number of distinct index-labels.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/loop_einsum.jl#LL4-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.@ein-Tuple" href="#OMEinsum.@ein-Tuple"><code>OMEinsum.@ein</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@ein A[i,k] := B[i,j] * C[j,k]     # A = B * C</code></pre><p>Macro interface similar to that of other packages.</p><p>You may use numbers in place of letters for dummy indices, as in <code>@tensor</code>, and need not name the output array. Thus <code>A = @ein [1,2] := B[1,ξ] * C[ξ,2]</code> is equivalent to the above. This can also be written <code>A = ein&quot;ij,jk -&gt; ik&quot;(B,C)</code> using the numpy-style string macro.</p><p><strong>example</strong></p><pre><code class="language-julia-repl">julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; @ein c[i,k] := a[i,j] * b[j,k];

julia&gt; c ≈ a * b
true

julia&gt; c ≈ ein&quot;ij,jk -&gt; ik&quot;(a,b)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/interfaces.jl#LL111-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.@ein_str-Tuple{AbstractString}" href="#OMEinsum.@ein_str-Tuple{AbstractString}"><code>OMEinsum.@ein_str</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">ein&quot;ij,jk -&gt; ik&quot;(A,B)</code></pre><p>String macro interface which understands <code>numpy.einsum</code>&#39;s notation. Translates strings into <code>EinCode</code>-structs that can be called to evaluate an <code>einsum</code>. To control evaluation order, use parentheses - instead of an <code>EinCode</code>, a <code>NestedEinsumStable</code> is returned which evaluates the expression according to parens. The valid character ranges for index-labels are <code>a-z</code> and <code>α-ω</code>.</p><p><strong>example</strong></p><pre><code class="language-julia-repl">julia&gt; a, b, c = rand(10,10), rand(10,10), rand(10,1);

julia&gt; ein&quot;ij,jk,kl -&gt; il&quot;(a,b,c) ≈ ein&quot;(ij,jk),kl -&gt; il&quot;(a,b,c) ≈ a * b * c
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/interfaces.jl#LL2-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.IndexGroup" href="#OMEinsum.IndexGroup"><code>OMEinsum.IndexGroup</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IndexGroup</code></pre><p>Leaf in a contractiontree, contains the indices and the number of the tensor it describes, e.g. in &quot;ij,jk -&gt; ik&quot;, indices &quot;ik&quot; belong to tensor <code>1</code>, so would be described by IndexGroup([&#39;i&#39;,&#39;k&#39;], 1).</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/einsequence.jl#LL88-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.NestedEinsum" href="#OMEinsum.NestedEinsum"><code>OMEinsum.NestedEinsum</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NestedEinsum</code></pre><p>describes a (potentially) nested einsum. Important fields:</p><ul><li><code>args</code>, vector of all inputs, either <code>IndexGroup</code> objects corresponding to tensors or <code>NestedEinsum</code></li><li><code>iy</code>, indices of output</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/einsequence.jl#LL103-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.NestedEinsum-Tuple" href="#OMEinsum.NestedEinsum-Tuple"><code>OMEinsum.NestedEinsum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>apply a NestedEinsum to arguments evaluates the nested einsum</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/einsequence.jl#LL156-L158">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Union{Tuple{T}, Tuple{EinArray{T,N,TT,LX,LY,ICT,OCT} where OCT where ICT where LY where LX where TT where N,Any}} where T" href="#Base.getindex-Union{Tuple{T}, Tuple{EinArray{T,N,TT,LX,LY,ICT,OCT} where OCT where ICT where LY where LX where TT where N,Any}} where T"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">getindex(A::EinArray, inds...)</code></pre><p>return the lazily calculated entry of <code>A</code> at index <code>inds</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/Core.jl#LL138-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.allunique-Tuple{Tuple{Vararg{T,N}} where T where N}" href="#OMEinsum.allunique-Tuple{Tuple{Vararg{T,N}} where T where N}"><code>OMEinsum.allunique</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">allunique(ix::Tuple)</code></pre><p>return true if all elements of <code>ix</code> appear only once in <code>ix</code>.</p><p><strong>example</strong></p><pre><code class="language-julia-repl">julia&gt; using OMEinsum: allunique

julia&gt; allunique((1,2,3,4))
true

julia&gt; allunique((1,2,3,1))
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/utils.jl#LL42-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.asarray-Tuple{Number}" href="#OMEinsum.asarray-Tuple{Number}"><code>OMEinsum.asarray</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">asarray(x::Number[, parent::AbstractArray]) -&gt; AbstactArray</code></pre><p>Return a 0-dimensional array with item <code>x</code>. If a <code>parent</code> is supplied, it will try to match the parent array type.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/utils.jl#LL1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.bpcheck-Tuple{Any,Vararg{Any,N} where N}" href="#OMEinsum.bpcheck-Tuple{Any,Vararg{Any,N} where N}"><code>OMEinsum.bpcheck</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bpcheck(f, args...; η = 1e-5, verbose=false)</code></pre><p>returns a <code>Bool</code> indicating whether Zygote calculates the gradient of <code>f(args...) -&gt; scalar</code> correctly using the relation <code>f(x - ηg) ≈ f(x) - η|g|²</code> with a relative tolerance of 1e-2 and an absolute tolerance of 1e-8. If <code>verbose=true</code>, print <code>f(x) - f(x - ηg)</code>and <code>η|g|²</code>.</p><p><strong>example</strong></p><pre><code class="language-julia-repl">julia&gt; using OMEinsum: bpcheck

julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; bpcheck(sum ∘ ein&quot;ij,jk -&gt; ik&quot;, a, b)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/autodiff.jl#LL45-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.check_dimensions-Tuple{IndexSize}" href="#OMEinsum.check_dimensions-Tuple{IndexSize}"><code>OMEinsum.check_dimensions</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">check_dimensions(inds::IndexSize)</code></pre><p>check whether all non-unique indexlabels point to the same dimension - otherwise throw an error.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/interfaces.jl#LL95-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.einsum_grad-Union{Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs,iy},Any,Any,Any,Any}} where iy where ixs" href="#OMEinsum.einsum_grad-Union{Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs,iy},Any,Any,Any,Any}} where iy where ixs"><code>OMEinsum.einsum_grad</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">einsum_grad(::EinCode{ixs, iy}, xs, size_dict, cdy, i)</code></pre><p>return the gradient of the result of evaluating the <code>EinCode</code> w.r.t the <code>i</code>th tensor in <code>xs</code>. <code>cdy</code> is the result of applying the <code>EinCode</code> to the <code>xs</code>.</p><p><strong>example</strong></p><pre><code class="language-julia-repl">julia&gt; using OMEinsum: einsum_grad, get_size_dict

julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; c = einsum(EinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)), (&#39;i&#39;,&#39;k&#39;)), (a,b));

julia&gt; sd = get_size_dict(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)), (a,b));

julia&gt; einsum_grad(EinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)), (&#39;i&#39;,&#39;k&#39;)), (a,b), sd, c, 1) ≈ c * transpose(b)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/autodiff.jl#LL3-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.extractixs-Tuple{OMEinsum.IndexGroup}" href="#OMEinsum.extractixs-Tuple{OMEinsum.IndexGroup}"><code>OMEinsum.extractixs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>extract the indices of the tensor that is associated with x (if x isa IndexGroup) or results from x (if x isa NestedEinsum)</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/einsequence.jl#LL165-L168">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.extractxs-Tuple{Any,OMEinsum.NestedEinsum}" href="#OMEinsum.extractxs-Tuple{Any,OMEinsum.NestedEinsum}"><code>OMEinsum.extractxs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>extract the tensor associated with x (if x isa IndexGroup) or evaluate and return the tensor associated with x (if x isa NestedEinsum)</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/einsequence.jl#LL172-L175">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.filliys!-Tuple{Any}" href="#OMEinsum.filliys!-Tuple{Any}"><code>OMEinsum.filliys!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">filliys!(neinsum::NestedEinsum)</code></pre><p>goes through all <code>NestedEinsum</code> objects in the tree and saves the correct <code>iy</code> in them.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/einsequence.jl#LL67-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.get_size_dict-Union{Tuple{X}, Tuple{T}, Tuple{N}, Tuple{Tuple{Vararg{Tuple{Vararg{T,M}} where M,N}},Tuple{Vararg{AbstractArray,X}}}} where X where T where N" href="#OMEinsum.get_size_dict-Union{Tuple{X}, Tuple{T}, Tuple{N}, Tuple{Tuple{Vararg{Tuple{Vararg{T,M}} where M,N}},Tuple{Vararg{AbstractArray,X}}}} where X where T where N"><code>OMEinsum.get_size_dict</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">get_size_dict(ixs, xs)</code></pre><p>return the <code>IndexSize</code> struct that is used to get the size of an index-label in the einsum-specification with input-indices <code>ixs</code> and tensors <code>xs</code> after consistency within <code>ixs</code> and between <code>ixs</code> and <code>xs</code> has been verified.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/interfaces.jl#LL50-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.indices_and_locs-Tuple{Any,Any}" href="#OMEinsum.indices_and_locs-Tuple{Any,Any}"><code>OMEinsum.indices_and_locs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">indices_and_locs(ixs,iy)</code></pre><p>given the index-labels of input and output of an <code>einsum</code>, return (in the same order):</p><ul><li>a tuple of the distinct index-labels of the output <code>iy</code></li><li>a tuple of the distinct index-labels in <code>ixs</code> of the input not appearing in the output <code>iy</code></li><li>a tuple of tuples of locations of an index-label in the <code>ixs</code> in a list of all index-labels</li><li>a tuple of locations of index-labels in <code>iy</code> in a list of all index-labels</li></ul><p>where the list of all index-labels is simply the first  and the second output catenated and the second output catenated.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/Core.jl#LL156-L167">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.map_prod-Union{Tuple{N}, Tuple{Tuple,Any,Tuple{Vararg{Any,N}}}} where N" href="#OMEinsum.map_prod-Union{Tuple{N}, Tuple{Tuple,Any,Tuple{Vararg{Any,N}}}} where N"><code>OMEinsum.map_prod</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">map_prod(xs, ind, indexers)</code></pre><p>calculate the value of an <code>EinArray</code> with <code>EinIndexer</code>s <code>indexers</code> at location <code>ind</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/Core.jl#LL146-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.match_rule-Tuple{Any,Any}" href="#OMEinsum.match_rule-Tuple{Any,Any}"><code>OMEinsum.match_rule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">match_rule(ixs, iy)</code></pre><p>go through all operations specified in the <code>einsum_rules</code>-vector and return the first <code>T</code> for which <code>match_rule(T, ixs, iy)</code> returns true.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/EinRule.jl#LL97-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.match_rule-Tuple{Type{OMEinsum.Hadamard},Any,Any}" href="#OMEinsum.match_rule-Tuple{Type{OMEinsum.Hadamard},Any,Any}"><code>OMEinsum.match_rule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Hadamard</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/EinRule.jl#LL51-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.match_rule-Tuple{Type{OMEinsum.PTrace},Any,Any}" href="#OMEinsum.match_rule-Tuple{Type{OMEinsum.PTrace},Any,Any}"><code>OMEinsum.match_rule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Ptrace rule if all indices of one ix in ixs all appear in iy or appear twice and don&#39;t appear in iy</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/EinRule.jl#LL58-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.match_rule-Tuple{Type{OMEinsum.Permutedims},Any,Any}" href="#OMEinsum.match_rule-Tuple{Type{OMEinsum.Permutedims},Any,Any}"><code>OMEinsum.match_rule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>permutation rule</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/EinRule.jl#LL41-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.match_rule-Tuple{Type{OMEinsum.Sum},Any,Any}" href="#OMEinsum.match_rule-Tuple{Type{OMEinsum.Sum},Any,Any}"><code>OMEinsum.match_rule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>a einsum code is sum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/EinRule.jl#LL32-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.match_rule-Tuple{Type{OMEinsum.Tr},Any,Any}" href="#OMEinsum.match_rule-Tuple{Type{OMEinsum.Tr},Any,Any}"><code>OMEinsum.match_rule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>a einsum code is trace</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/EinRule.jl#LL15-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.match_rule-Union{Tuple{T}, Tuple{M}, Tuple{N}, Tuple{Type{PairWise},Tuple{Vararg{Tuple{Vararg{T,X}} where X,N}},Tuple{Vararg{T,M}}}} where T where M where N" href="#OMEinsum.match_rule-Union{Tuple{T}, Tuple{M}, Tuple{N}, Tuple{Type{PairWise},Tuple{Vararg{Tuple{Vararg{T,X}} where X,N}},Tuple{Vararg{T,M}}}} where T where M where N"><code>OMEinsum.match_rule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>a einsum code is a pairwise graph.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/EinRule.jl#LL24-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.nopermute-Tuple{Tuple{Vararg{T,N}} where T where N,Tuple{Vararg{T,N}} where T where N}" href="#OMEinsum.nopermute-Tuple{Tuple{Vararg{T,N}} where T where N,Tuple{Vararg{T,N}} where T where N}"><code>OMEinsum.nopermute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">nopermute(ix,iy)</code></pre><p>check that all values in <code>iy</code> that are also in <code>ix</code> have the same relative order,</p><p><strong>example</strong></p><pre><code class="language-julia-repl">julia&gt; using OMEinsum: nopermute

julia&gt; nopermute((1,2,3),(1,2))
true

julia&gt; nopermute((1,2,3),(2,1))
false</code></pre><p>e.g. <code>nopermute((1,2,3),(1,2))</code> is true while <code>nopermute((1,2,3),(2,1))</code> is false</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/utils.jl#LL13-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.parse_parens-Tuple{AbstractString,Any,Any}" href="#OMEinsum.parse_parens-Tuple{AbstractString,Any,Any}"><code>OMEinsum.parse_parens</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">parse_parens(s::AbstractString, i, narg)</code></pre><p>parse one level of parens starting at index <code>i</code> where <code>narg</code> counts which tensor the current group of indices, e.g. &quot;ijk&quot;, belongs to. Recursively calls itself for each new opening paren that&#39;s opened.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/einsequence.jl#LL19-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.stabilize-Tuple{OMEinsum.NestedEinsum}" href="#OMEinsum.stabilize-Tuple{OMEinsum.NestedEinsum}"><code>OMEinsum.stabilize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">stabilize(nein::NestedEinsum)</code></pre><p>turn the nested einsum into a <code>NestedEinsumStable</code> which is type-stable and more performant.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f2c7b502b30d78a0f3630c55bcc98f8d5728282b/src/einsequence.jl#LL184-L190">source</a></section><footer><hr/><a class="previous" href="../extending/"><span class="direction">Previous</span><span class="title">Extending OMEinsum</span></a></footer></article></body></html>
