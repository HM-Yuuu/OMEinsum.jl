var documenterSearchIndex = {"docs":
[{"location":"#OMEinsum.jl-1","page":"Home","title":"OMEinsum.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [OMEinsum]","category":"page"},{"location":"#OMEinsum.einsum-Union{Tuple{T}, Tuple{N}, Tuple{Tuple{Vararg{Tuple{Vararg{T,M}} where M,N}},Tuple{Vararg{AbstractArray{#s14,M} where #s14 where M,N}},Tuple{Vararg{T,#s15}} where #s15}} where T where N","page":"Home","title":"OMEinsum.einsum","text":"einsum(cs, ts, out)\n\nreturn the tensor that results from contracting the tensors ts according to their indices cs, where twice-appearing indices are contracted. The result is permuted according to out.\n\ncs - tuple of tuple of integers that label all indices of a tensor.      Indices that appear twice (in different tensors) are summed over\nts - tuple of tensors\nout - tuple of integers that should correspond to remaining indices in cs after contractions.\n\nThis implementation has space requirements that are exponential in the number of unique indices.\n\nexample\n\njulia> a = rand(2,2);\n\njulia> b = rand(2,2);\n\njulia> einsum(((1,2),(2,3)), (a, b), (1,3)) ≈ a * b\ntrue\n\njulia> einsum(((1,2),(2,3)), (a, b), (3,1)) ≈ permutedims(a * b, (2,1))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#OMEinsum.expandall!-NTuple{4,Any}","page":"Home","title":"OMEinsum.expandall!","text":"expandall!(b::AbstractArray{T,N}, indsb::NTuple{<:Any,N},\n           a::AbstractArray{T,M}, indsa::NTuple{<:Any,M})\n\nexpands a into b by finding all index-labels in indsa in indsb and in case an label appears more in indsb than in indsa, the corresponding index is expanded. This enables operations such as\n\njulia> OMEinsum.expandall!(zeros(2,2), (1,1), reshape([2]), ())\n2×2 Array{Float64,2}:\n 2.0  0.0\n 0.0  2.0\n\nwhere the zero-dimensional array reshape([2]) is expanded onto the diagonal of zeros(2,2) as in the backward action of taking the diagonal. Expansions are done by contracting a dirac-delta function with the indices to expand.\n\n\n\n\n\n","category":"method"},{"location":"#OMEinsum.contractcombine!-NTuple{5,Any}","page":"Home","title":"OMEinsum.contractcombine!","text":"contractcombine!(out, outindspre, outinds, contractions, tensors)\n\ntake the tensorproduct of all tensors in tensors according to the specification in contractions and save the result in out.\n\n\n\n\n\n","category":"method"},{"location":"#OMEinsum.diagonal-Union{Tuple{N}, Tuple{AbstractArray{#s14,N} where #s14,Tuple{Vararg{T,N}} where T}} where N","page":"Home","title":"OMEinsum.diagonal","text":"diagonal(tensor::AbstractArray{<:Any,N}, inds::NTuple{N})\n\nif there are any duplicate labels in inds, take those elements of tensor for which the indices for the duplicate labels are the same, i.e. if ind = (1,2,2), make a new tensor from the slices tensor[i,j,j]. If multiple duplicate labels are in inds recursively calls itself until none are left.\n\nExample\n\njulia> OMEinsum.diagonal([1 2; 3 4], (1,1))\n([1, 4], (1,))\n\n\n\n\n\n","category":"method"},{"location":"#OMEinsum.diagonals-Tuple{Any,Any}","page":"Home","title":"OMEinsum.diagonals","text":"diagonals(tensors, contractions)\n\nfor each tensor in tensors, check whether there are any duplicates in contractions. If there are duplicates, take the diagonal w.r.t to the duplicates and return these diagonals and the new contractions.\n\nExample\n\njulia> OMEinsum.diagonals(([1 2; 3 4],), ((1,1),))\n(([1, 4],), ((1,),))\n\n\n\n\n\n","category":"method"},{"location":"#OMEinsum.permuteandreshape-Tuple{Any,Any,Any}","page":"Home","title":"OMEinsum.permuteandreshape","text":"permuteandreshape(uniqueallins, tensor, inds)\n\npermute tensor such that its indices in inds are in the same order as in uniqueallins. Then reshape the permuted tensor such that the indices of the resulting tensors for indices in inds is conserved while singleton-dimensions are inserted for indices in uniqueallins that are not in inds.\n\nExample\n\nHere, the array [1 2;3 4] is permuted according to the indices in uniqueallins, where label 1 comes before label 4 and then reshape it to have a shape that could be indexed with four labels.\n\njulia> OMEinsum.permuteandreshape((1,2,3,4), [1 2; 3 4], (4,1))\n2×1×1×2 Array{Int64,4}:\n[:, :, 1, 1] =\n 1\n 2\n\n[:, :, 1, 2] =\n 3\n 4\n\n\n\n\n\n","category":"method"}]
}
