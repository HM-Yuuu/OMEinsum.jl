var documenterSearchIndex = {"docs":
[{"location":"#OMEinsum.jl-1","page":"Home","title":"OMEinsum.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [OMEinsum]","category":"page"},{"location":"#OMEinsum.einsum-Union{Tuple{N}, Tuple{Tuple{Vararg{Tuple{Vararg{Int64,M}} where M,N}},Tuple{Vararg{Array{#s14,M} where #s14 where M,N}},Tuple{Vararg{Int64,#s15}} where #s15}} where N","page":"Home","title":"OMEinsum.einsum","text":"einsum(cs, ts, out)\n\nreturn the tensor that results from contracting the tensors ts according to their indices cs, where twice-appearing indices are contracted. The result is permuted according to out.\n\ncs - tuple of tuple of integers that label all indices of a tensor.      Indices that appear twice (in different tensors) are summed over\nts - tuple of tensors\nout - tuple of integers that should correspond to remaining indices in cs after contractions.\n\nThis implementation has space requirements that are exponential in the number of unique indices.\n\nexample\n\njulia> a = rand(2,2);\n\njulia> b = rand(2,2);\n\njulia> einsum(((1,2),(2,3)), (a, b), (1,3)) ≈ a * b\ntrue\n\njulia> einsum(((1,2),(2,3)), (a, b), (3,1)) ≈ permutedims(a * b, (2,1))\ntrue\n\n\n\n\n\n","category":"method"}]
}
