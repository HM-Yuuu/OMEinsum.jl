<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parsing · OMEinsum.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>OMEinsum.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Parsing</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Input-(Nested)-1">Input (Nested)</a></li></ul></li><li><a class="toctext" href="../implementation/">Implementations</a></li><li><a class="toctext" href="../extending/">Extending OMEinsum</a></li><li><a class="toctext" href="../docstrings/">DocStrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Parsing</a></li></ul><a class="edit-page" href="https://github.com/under-Peter/OMEinsum.jl/blob/master/docs/src/parsing.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Parsing</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Input-(flat)-1" href="#Input-(flat)-1">Input (flat)</a></h1><p>An einsum specification should be given via the <code>ein_str</code> string-literal or with the <code>@ein</code>-macro as e.g.</p><pre><code class="language-julia">julia&gt; c = ein&quot;ij,jk -&gt; ik&quot;(a,b)
julia&gt; @ein c[i,k] := a[i,j] * b[j,k]</code></pre><p>where both specifications encode the same operation - a matrix multiplication. The <code>ein_str</code>-literal is parsed directly into an <code>EinCode</code> struct that holds the indices of the input <code>ixs = ((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;))</code> and output <code>iy = (&#39;i&#39;,&#39;k&#39;)</code> as type parameters, thus making them accessible at compile time.</p><p>The string-literal form thus gets turned into</p><pre><code class="language-julia">julia&gt; c = EinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)),(&#39;i&#39;,&#39;k&#39;))(a,b)</code></pre><p>Calling an <code>EinCode</code>-object gets lowered to</p><pre><code class="language-julia">julia&gt; c = einsum(EinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)),(&#39;i&#39;,&#39;k&#39;)), (a,b), size_dict = nothing)</code></pre><p>where <code>nothing</code> is the default argument for the (as of yet not used during specification) <code>size_dict</code>, which could allow to provide dimensions for index-labels that only appear in the output.</p><p>In the next step, a singleton-subtype of the abstract type <code>EinRule</code> is chosen which is later used for dispatch. Subtypes of <code>EinRule</code> specify the kind of operation and are created in such a way that they allow useful dispatch. They are defined in <code>EinRule.jl</code>.</p><p>The possible types are:</p><ul><li><code>Identity</code> - operation is the identity on <em>one</em> tensor, e.g. <code>ein&quot;ijk -&gt; ijk&quot;</code></li><li><code>MatMul</code> - operation is a matrix multiplication of <em>two</em> matrices, possibly with permutations of inputs and/or outputs, e.g. <code>ein&quot;ij,kj -&gt; ik&quot;</code></li><li><code>Permutedims</code> - operation is a permutation of the indices of <em>one</em> tensor, e.g. <code>ein&quot;ijk -&gt; jki&quot;</code></li><li><code>Hadamard</code> - operation is a hadamard-product of arbitrary many tensors, e.g. <code>ein&quot;ij,ij,ij -&gt; ij&quot;</code></li><li><code>Tr</code> - operation is a trace of <em>one</em> matrix, e.g. <code>ein&quot;ii -&gt;&quot;</code></li><li><code>PTrace</code> - operation is a partial trace of <em>one</em> tensor, e.g. <code>ein&quot;iij -&gt; j&quot;</code></li><li><code>Sum</code> - operation is a reduction over one or more indices of <em>one</em> tensor, e.g. <code>ein&quot;ijkl -&gt; il&quot;</code></li><li><code>PairWise</code> - operation is a tensor-contraction over arbitrary many tensors, e.g. <code>ein&quot;ijk,kl,lmn,no -&gt; ijmo&quot;</code></li><li><code>DefaultRule</code> - default if none of the above match, e.g. <code>ein&quot;ij,ik,il -&gt; jkl&quot;</code></li></ul><p>Since <code>ixs</code> and <code>iy</code> are saved as type-parameters, the operation-matching can happen at compile time. The operation is chosen using <code>match_rule(ixs,iy)</code> by testing all subtypes of <code>EinRule</code> in the sequence above (top to bottom) and picking the first match.</p><p>This enables us to chose <code>MatMul</code> for a  matrix multiplication which is also a legal tensor-contraction, i.e. a <code>PairWise</code>, assuming that we can have a lower-overhead implementation for <code>MatMul</code> than <code>PairWise</code>.</p><p>We proceed by calling <code>einsum(&lt;:EinRule, &lt;:EinCode, xs, size_dict)</code> which dispatches on the <code>EinRule</code> and the type of <code>xs</code> - the latter enables us to dispatch to e.g. cuda-specific routines for certain operations (as done in the <code>cueinsum.jl</code> file).</p><p>In the case of the matrix-multiplication above, <code>einsum</code> calls <code>*</code> which can dispatch to efficient routines for most <code>Array</code>-types including <code>CuArray</code>.</p><h1><a class="nav-anchor" id="Input-(Nested)-1" href="#Input-(Nested)-1">Input (Nested)</a></h1><p>Whether with the <code>ein_str</code> string-literal or the <code>@ein</code> macro, nested expressions are mapped to a nested struct. Consider the example</p><pre><code class="language-julia">julia&gt; c = ein&quot;(ij,jk),kl -&gt; il&quot;(a,b,c)
julia&gt; @ein c[i,l] := (a[i,j] * b[j,k]) * c[k,l]</code></pre><p>which is a simply a product of three matrices evaluated as two matrix products in sequence.</p><p>This is equivalent to</p><pre><code class="language-julia">julia&gt; c = ein&quot;ik,kl -&gt; il&quot;(ein&quot;ij,jk -&gt; ik&quot;(a,b),c)
julia&gt; @ein ab[i,k] := a[i,j] * b[j,k]
julia&gt; @ein c[i,l] := ab[i,k] * c[k,l]</code></pre><p>and is expressed as a nested structure <code>NestedEinsumStable</code> which contains the <code>EinCode</code>s for the intermediate calculations as well as some logic to assign the correct input and output tensors to the correct <code>EinCode</code>.</p><p><code>NestedEinsumStable</code> has the following definition:</p><pre><code class="language-julia">struct NestedEinsumStable{T,S,N}
    args::S
    eins::T
end</code></pre><p>where the <code>eins</code>-field contains an <code>EinCode</code> of <code>N</code> arguments and <code>args</code> holds the arguments to that <code>EinCode</code> which can either be a integer to label a tensor or a <code>NestedEinsumStable</code> itself. The labeling works such that the <code>i</code>th input is represented by the number <code>i</code>.</p><p>Upon application to tensors, a <code>NestedEinsumStable</code> evaluates its arguments. If the argument is an integer <code>i</code>, the <code>i</code>th provided tensor is chosen, otherwise the <code>NestedEinsumStable</code> is evaluated.</p><p>To make it more concrete, consider the <code>NestedEinsumStable</code> for the expression above, where for easier reading the type signatures were removed and the <code>EinCode</code>-structs were replaced by <code>ein</code>-string literals.</p><pre><code class="language-julia">julia&gt; ein&quot;(ij,jk),kl -&gt; il&quot;
 NestedEinsumStable{...}((NestedEinsumStable{...}((1, 2), ein&quot;ij,jk -&gt; ik&quot;), 3), ein&quot;ik,kl -&gt; il&quot;)</code></pre><p>Evaluating this expression with three arguments leads to the inner <code>NestedEinsumStable</code> to be evaluated first with the first and second argument and the specifiation <code>ein&quot;ij,jk -&gt; ik&quot;</code>. Then the result of that is given as the first argument to <code>ein&quot;ik,kl -&gt; il&quot;</code> with the third argument as the second input.</p><p>To improve understanding, you might replace the integers with <code>getindex</code> operations in your head</p><pre><code class="language-julia">ein&quot;(ij,jk),kl -&gt; il&quot;(xs...)
⇒ NestedEinsumStable{...}((NestedEinsumStable{...}((xs[1], xs[2]), ein&quot;ij,jk -&gt; ik&quot;), xs[3]), ein&quot;ik,kl -&gt; il&quot;)</code></pre><p>and finally turn it into</p><pre><code class="language-julia">ein&quot;(ij,jk),kl -&gt; il&quot;(xs...)
⇒ ein&quot;ik,kl -&gt; il&quot;(ein&quot;ij,jk -&gt; ik&quot;(xs[1], xs[2]), xs[3])</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../implementation/"><span class="direction">Next</span><span class="title">Implementations</span></a></footer></article></body></html>
