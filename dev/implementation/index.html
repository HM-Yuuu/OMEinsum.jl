<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementations · OMEinsum.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>OMEinsum.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../parsing/">Parsing</a></li><li class="current"><a class="toctext" href>Implementations</a><ul class="internal"><li><a class="toctext" href="#Identity-1">Identity</a></li><li><a class="toctext" href="#Matrix-Multiplication-1">Matrix Multiplication</a></li><li><a class="toctext" href="#Index-Permutation-1">Index-Permutation</a></li><li><a class="toctext" href="#Hadamard-1">Hadamard</a></li><li><a class="toctext" href="#Trace-1">Trace</a></li><li><a class="toctext" href="#Partial-Trace-1">Partial Trace</a></li><li><a class="toctext" href="#Sum-1">Sum</a></li><li><a class="toctext" href="#Tensor-Contractions-(PairWise)-1">Tensor-Contractions (PairWise)</a></li><li><a class="toctext" href="#Fallback-1">Fallback</a></li></ul></li><li><a class="toctext" href="../extending/">Extending OMEinsum</a></li><li><a class="toctext" href="../docstrings/">DocStrings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Implementations</a></li></ul><a class="edit-page" href="https://github.com/under-Peter/OMEinsum.jl/blob/master/docs/src/implementation.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Implementations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Implementations-1" href="#Implementations-1">Implementations</a></h1><h2><a class="nav-anchor" id="Identity-1" href="#Identity-1">Identity</a></h2><p>To test whether a specification <code>ixs,iy</code> is the identity, it is checked whether <code>ixs</code> is made up of <em>one</em> tuple of index-labels that is equal to <code>iy</code> <em>and</em> that all index-labels in <code>iy</code> are unique - the latter to distuingish identity from e.g. projection to the diagonal like <code>ein&quot;ii -&gt; ii&quot;</code>.</p><p>The identity operation simply returns the first (and only) tensor argument to <code>einsum</code>.</p><h2><a class="nav-anchor" id="Matrix-Multiplication-1" href="#Matrix-Multiplication-1">Matrix Multiplication</a></h2><p>A specification <code>ixs,iy</code> is a matrix multiplication if <code>ixs</code> consists of two 2-tuples that share <em>one</em> index-label and <code>iy</code> is a permutation of the two-nonshared index-labels of the <code>ixs</code>.</p><p>Matrix multiplication uses a generated function to return a matrix-product with at most one application of <code>transpose</code>, such that e.g. <code>ein&quot;ij,jk -&gt; ik&quot;(a,b)</code> returns <code>:(a * b)</code> and <code>ein&quot;ij,kj -&gt; ki&quot;(a,b)</code> returns <code>:(b * transpose(a))</code>.</p><h2><a class="nav-anchor" id="Index-Permutation-1" href="#Index-Permutation-1">Index-Permutation</a></h2><p>A specification <code>ixs,iy</code> is an index-permutation if <code>ixs</code> is a tuple containing one tuple of index-labels that are all unique and are a permutation of the labels in <code>iy</code>.</p><p>Index-permutation is implemented with <code>permutedims</code> and a permutation that&#39;s calculated at runtime.</p><h2><a class="nav-anchor" id="Hadamard-1" href="#Hadamard-1">Hadamard</a></h2><p>A specification <code>ixs, iy</code> is a hadamard-product if <code>ixs</code> is a tuple that contains copies of <code>iy</code> and nothing else and <code>iy</code> contains no duplicates.</p><p>The hadamard-product is implemented by broadcasting <code>*</code> over the tensors. If some of the index-labels in <code>ixs</code> are permutations of <code>iy</code>, we found that doing the permutation and then broadcasting <code>*</code> had worse performance than the fallback implementation below - we are thus rather strict about what is a hadamard-product.</p><h2><a class="nav-anchor" id="Trace-1" href="#Trace-1">Trace</a></h2><p>A specification <code>ixs, iy</code> is a trace if <code>iy</code> is empty and <code>ixs</code> contains one 2-tuple containing the same index-label twice.</p><p>A trace dispatches to the <code>LinearAlgebra.tr</code> although the result is wrapped in a 0-dimensional array for type stability since all <code>einsum</code> return <code>AbstractArray</code>s.</p><h2><a class="nav-anchor" id="Partial-Trace-1" href="#Partial-Trace-1">Partial Trace</a></h2><p>A specification <code>ixs, iy</code> is a partial trace if <code>iy</code> contains no duplicates and <code>ixs</code> is a tuple containing one tuple of index-labels that contains all index-labels in <code>iy</code> plus pairs of labels not in <code>iy</code> in arbitrary order.</p><p>Partial traces are implemented using <code>TensorOperations.jl</code> for regular <code>AbstractArray</code>s and with the Fallback-option (see below) for <code>CuArray</code>s, since at this point <code>TensorOperations.jl</code> lacks full GPU support.</p><h2><a class="nav-anchor" id="Sum-1" href="#Sum-1">Sum</a></h2><p>A specification <code>ixs,iy</code> is a sum or a reduction over indices if all indices in <code>iy</code> are unique and contained in the only tuple in <code>ixs</code> that additionally contains unique labels (that are reduced over).</p><p>Index-reductions are implemented using <code>Base.sum</code> and <code>Base.dropdims</code> - the latter to remove the singleton-dimensions left over after summing over a dimension.</p><h2><a class="nav-anchor" id="Tensor-Contractions-(PairWise)-1" href="#Tensor-Contractions-(PairWise)-1">Tensor-Contractions (PairWise)</a></h2><p>A specification <code>ixs,iy</code> corresponds to tensor-contractions if all all labels in <code>iy</code> are unique and all indices appear exactly twice in <code>ixs</code> and <code>iy</code>.</p><p>Such operations can be dispatched to <code>TensorOperations.jl</code> and are evaluated using the <code>@tensoropt</code> macro which chooses a suitable contraction order for the problem for all <code>AbstractArray</code> except <code>CuArray</code>s which are implemented using the Fallback.</p><h2><a class="nav-anchor" id="Fallback-1" href="#Fallback-1">Fallback</a></h2><p>The fallback is called for any specification that does not satisfy the criteria outlined above.</p><p>The dispatch calls <code>loop_einsum</code> which is defined in <code>loop_einsum.jl</code>.</p><p><code>loop_einsum</code> is based on the <code>EinArray</code>-struct. An <code>EinArray</code> is a subtype of <code>AbstractArray</code> that represents an intermediate step in a general einsum-expression <em>before</em> reductions remove indices. Consider a specification <code>ixs,iy</code> - the <code>EinArray</code> for that specification is the array with an index for each (distinct) label in <code>ixs</code> and <code>iy</code>. As an example, in <code>ein&quot;ij,ik,il -&gt; jkl&quot;(a,b,c)</code>, the distinct labels are <code>(i,j,k,l)</code> and the corresponding <code>EinArray</code> <code>einarr</code> would be a rank-4 tensor with an index each for each distinct label.</p><p>If an entry of <code>einarr</code> is requested, e.g. <code>einarr[i₁,j₁,k₁,l₁]</code>, it&#39;s values is lazily constructed as <code>einarr[i₁,j₁,k₁,l₁] = a[i₁,j₁]*a[i₁,k₁]*a[i₁,l₁]</code> upon access - the lazy evaluation avoids constructing the whole array.</p><p>To get to the final result, we reduce over the dimensions that are missing in the output. By first allocating an array of the correct size, we can fill it up with the entries of the <code>EinArray</code> which are calculated on the fly, avoiding the allocation of the intermediate result.</p><p>Thus effectively we split an operation like <code>ein&quot;ij,ik,il -&gt; jkl&quot;(a,b,c)</code> into two piece: <code>einarr = ein&quot;ij,ik,il -&gt; ijkl&quot;(a,b,c)</code> and <code>ein&quot;ijkl -&gt; jkl&quot;(einarr)</code> but treat the first operation as a lazy one - this way we can use <code>mapreduce(identity, +)</code> over the dimensions we want to remove which is implemented efficiently for both regular <code>Array</code>s and <code>CuArray</code>s.</p><footer><hr/><a class="previous" href="../parsing/"><span class="direction">Previous</span><span class="title">Parsing</span></a><a class="next" href="../extending/"><span class="direction">Next</span><span class="title">Extending OMEinsum</span></a></footer></article></body></html>
