<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · OMEinsum.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>OMEinsum.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul><a class="edit-page" href="https://github.com/under-Peter/OMEinsum.jl/blob/master/docs/src/index.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="OMEinsum.jl-1" href="#OMEinsum.jl-1">OMEinsum.jl</a></h1><ul><li><a href="#OMEinsum.Diag"><code>OMEinsum.Diag</code></a></li><li><a href="#OMEinsum.EinsumOp"><code>OMEinsum.EinsumOp</code></a></li><li><a href="#OMEinsum.Fallback"><code>OMEinsum.Fallback</code></a></li><li><a href="#OMEinsum.IndexGroup"><code>OMEinsum.IndexGroup</code></a></li><li><a href="#OMEinsum.IndexReduction"><code>OMEinsum.IndexReduction</code></a></li><li><a href="#OMEinsum.MixedDiag"><code>OMEinsum.MixedDiag</code></a></li><li><a href="#OMEinsum.MixedStarContract"><code>OMEinsum.MixedStarContract</code></a></li><li><a href="#OMEinsum.NestedEinsum"><code>OMEinsum.NestedEinsum</code></a></li><li><a href="#OMEinsum.NestedEinsum-Tuple"><code>OMEinsum.NestedEinsum</code></a></li><li><a href="#OMEinsum.OuterProduct"><code>OMEinsum.OuterProduct</code></a></li><li><a href="#OMEinsum.Permutation"><code>OMEinsum.Permutation</code></a></li><li><a href="#OMEinsum.StarContract"><code>OMEinsum.StarContract</code></a></li><li><a href="#OMEinsum.TensorContract"><code>OMEinsum.TensorContract</code></a></li><li><a href="#OMEinsum.Trace"><code>OMEinsum.Trace</code></a></li><li><a href="#OMEinsum.allunique-Tuple{Tuple{Vararg{T,N}} where T where N}"><code>OMEinsum.allunique</code></a></li><li><a href="#OMEinsum.bpcheck-Tuple{Any,Vararg{Any,N} where N}"><code>OMEinsum.bpcheck</code></a></li><li><a href="#OMEinsum.combineops-Union{Tuple{S}, Tuple{T}, Tuple{T,S}} where S&lt;:OMEinsum.EinsumOp where T&lt;:OMEinsum.EinsumOp"><code>OMEinsum.combineops</code></a></li><li><a href="#OMEinsum.edgesfrominds-Tuple{Any,Any}"><code>OMEinsum.edgesfrominds</code></a></li><li><a href="#OMEinsum.einsum-Union{Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs,iy},Any,Any}} where iy where ixs"><code>OMEinsum.einsum</code></a></li><li><a href="#OMEinsum.einsum_grad-Union{Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs,iy},Any,Any,Any,Any}} where iy where ixs"><code>OMEinsum.einsum_grad</code></a></li><li><a href="#OMEinsum.einsumcost-Tuple{Any,Any,Any}"><code>OMEinsum.einsumcost</code></a></li><li><a href="#OMEinsum.einsumexp-Union{Tuple{iy}, Tuple{ixs}, Tuple{T}, Tuple{N}, Tuple{EinCode{ixs,iy},Tuple{Vararg{AbstractArray{#s13,M} where #s13 where M,N}},Any}} where iy where ixs where T where N"><code>OMEinsum.einsumexp</code></a></li><li><a href="#OMEinsum.einsumexp!-Union{Tuple{iy}, Tuple{ixs}, Tuple{IT}, Tuple{T}, Tuple{L}, Tuple{N}, Tuple{EinCode{ixs,iy},Tuple{Vararg{AbstractArray{#s17,M} where #s17 where M,N}},AbstractArray{T,L},Any}} where iy where ixs where IT&lt;:Union{AbstractChar, Integer} where T where L where N"><code>OMEinsum.einsumexp!</code></a></li><li><a href="#OMEinsum.einsumopt-Union{Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs,iy},Any}} where iy where ixs"><code>OMEinsum.einsumopt</code></a></li><li><a href="#OMEinsum.evaluate-Tuple{OMEinsum.EinsumOp,Any,Any}"><code>OMEinsum.evaluate</code></a></li><li><a href="#OMEinsum.evaluateall-NTuple{4,Any}"><code>OMEinsum.evaluateall</code></a></li><li><a href="#OMEinsum.extractixs-Tuple{OMEinsum.IndexGroup}"><code>OMEinsum.extractixs</code></a></li><li><a href="#OMEinsum.extractxs-Tuple{Any,OMEinsum.NestedEinsum}"><code>OMEinsum.extractxs</code></a></li><li><a href="#OMEinsum.filliys!-Tuple{Any}"><code>OMEinsum.filliys!</code></a></li><li><a href="#OMEinsum.get_size_dict-Union{Tuple{X}, Tuple{T}, Tuple{N}, Tuple{Tuple{Vararg{Tuple{Vararg{T,M}} where M,N}},Tuple{Vararg{AbstractArray,X}}}} where X where T where N"><code>OMEinsum.get_size_dict</code></a></li><li><a href="#OMEinsum.index_map-Tuple{CartesianIndex,Tuple}"><code>OMEinsum.index_map</code></a></li><li><a href="#OMEinsum.indicesafteroperation-Tuple{OMEinsum.EinsumOp,Any}"><code>OMEinsum.indicesafteroperation</code></a></li><li><a href="#OMEinsum.iscombineable-Union{Tuple{S}, Tuple{T}, Tuple{T,S}} where S&lt;:OMEinsum.EinsumOp where T&lt;:OMEinsum.EinsumOp"><code>OMEinsum.iscombineable</code></a></li><li><a href="#OMEinsum.loop!-Union{Tuple{T}, Tuple{N}, Tuple{Tuple{Vararg{Any,N}},Tuple{Vararg{AbstractArray,N}},Any,AbstractArray{T,N} where N,CartesianIndices,CartesianIndices}} where T where N"><code>OMEinsum.loop!</code></a></li><li><a href="#OMEinsum.map_prod-Union{Tuple{T}, Tuple{N}, Tuple{Type{T},Tuple,CartesianIndex,Tuple{Vararg{Any,N}}}} where T where N"><code>OMEinsum.map_prod</code></a></li><li><a href="#OMEinsum.match_rule-Tuple{Any,Any}"><code>OMEinsum.match_rule</code></a></li><li><a href="#OMEinsum.match_rule-Tuple{Type{OMEinsum.PTrace},Any,Any}"><code>OMEinsum.match_rule</code></a></li><li><a href="#OMEinsum.match_rule-Tuple{Type{OMEinsum.Permutedims},Any,Any}"><code>OMEinsum.match_rule</code></a></li><li><a href="#OMEinsum.match_rule-Tuple{Type{OMEinsum.Hadamard},Any,Any}"><code>OMEinsum.match_rule</code></a></li><li><a href="#OMEinsum.match_rule-Tuple{Type{OMEinsum.Sum},Any,Any}"><code>OMEinsum.match_rule</code></a></li><li><a href="#OMEinsum.match_rule-Union{Tuple{T}, Tuple{M}, Tuple{N}, Tuple{Type{PairWise},Tuple{Vararg{Tuple{Vararg{T,X}} where X,N}},Tuple{Vararg{T,M}}}} where T where M where N"><code>OMEinsum.match_rule</code></a></li><li><a href="#OMEinsum.match_rule-Tuple{Type{OMEinsum.Tr},Any,Any}"><code>OMEinsum.match_rule</code></a></li><li><a href="#OMEinsum.nopermute-Tuple{Tuple{Vararg{T,N}} where T where N,Tuple{Vararg{T,N}} where T where N}"><code>OMEinsum.nopermute</code></a></li><li><a href="#OMEinsum.opcost-Tuple{OMEinsum.EinsumOp,Any,Any,Tuple{Vararg{Tuple{Vararg{Int64,N}} where N,M}} where M}"><code>OMEinsum.opcost</code></a></li><li><a href="#OMEinsum.operatorfromedge-Tuple{Any,Any,Any}"><code>OMEinsum.operatorfromedge</code></a></li><li><a href="#OMEinsum.operatorsfromedges-Tuple{Any,Any,Any}"><code>OMEinsum.operatorsfromedges</code></a></li><li><a href="#OMEinsum.optimalorder-Tuple{Any,Any,Any}"><code>OMEinsum.optimalorder</code></a></li><li><a href="#OMEinsum.optimiseorder-NTuple{4,Any}"><code>OMEinsum.optimiseorder</code></a></li><li><a href="#OMEinsum.overlap-Tuple{Any,Any}"><code>OMEinsum.overlap</code></a></li><li><a href="#OMEinsum.parse_parens-Tuple{AbstractString,Any,Any}"><code>OMEinsum.parse_parens</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.einsum-Union{Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs,iy},Any,Any}} where iy where ixs" href="#OMEinsum.einsum-Union{Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs,iy},Any,Any}} where iy where ixs"><code>OMEinsum.einsum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">einsum(::EinCode{ixs, iy}, out, size_dict) where {ixs, iy}</code></pre><p>return the tensor that results from contracting the tensors <code>xs</code> according to their indices <code>ixs</code>, where all indices that do not appear in the output are summed over. The indices are contracted in the order implied by their numerical value, smaller first. The result is permuted according to <code>out</code>.</p><ul><li><p><code>ixs</code> - tuple of tuple of integers that label all indices of a tensor.      Indices that appear twice (in different tensors) are summed over</p></li><li><p><code>xs</code> - tuple of tensors</p></li><li><p><code>out</code> - tuple of integers that should correspond to remaining indices in <code>ixs</code> after contractions.</p></li></ul><p><strong>example</strong></p><pre><code class="language-julia-repl">julia&gt; a = rand(2,2);

julia&gt; b = rand(2,2);

julia&gt; einsum(ein&quot;ij,jk-&gt;ij&quot;, (a, b)) ≈ a * b
true

julia&gt; einsum(ein&quot;ij,jk-&gt;ki&quot;, (a, b)) ≈ permutedims(a * b, (2,1))
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einsum.jl#LL4-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.einsumexp!-Union{Tuple{iy}, Tuple{ixs}, Tuple{IT}, Tuple{T}, Tuple{L}, Tuple{N}, Tuple{EinCode{ixs,iy},Tuple{Vararg{AbstractArray{#s17,M} where #s17 where M,N}},AbstractArray{T,L},Any}} where iy where ixs where IT&lt;:Union{AbstractChar, Integer} where T where L where N" href="#OMEinsum.einsumexp!-Union{Tuple{iy}, Tuple{ixs}, Tuple{IT}, Tuple{T}, Tuple{L}, Tuple{N}, Tuple{EinCode{ixs,iy},Tuple{Vararg{AbstractArray{#s17,M} where #s17 where M,N}},AbstractArray{T,L},Any}} where iy where ixs where IT&lt;:Union{AbstractChar, Integer} where T where L where N"><code>OMEinsum.einsumexp!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">einsumexp!(::EinCode, xs, y, size_dict)</code></pre><p>The inplace brute-force looping einsum, <code>y</code> is the output tensor.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einsumexp.jl#LL20-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.einsumexp-Union{Tuple{iy}, Tuple{ixs}, Tuple{T}, Tuple{N}, Tuple{EinCode{ixs,iy},Tuple{Vararg{AbstractArray{#s13,M} where #s13 where M,N}},Any}} where iy where ixs where T where N" href="#OMEinsum.einsumexp-Union{Tuple{iy}, Tuple{ixs}, Tuple{T}, Tuple{N}, Tuple{EinCode{ixs,iy},Tuple{Vararg{AbstractArray{#s13,M} where #s13 where M,N}},Any}} where iy where ixs where T where N"><code>OMEinsum.einsumexp</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">einsumexp(::EinCode, xs, size_dict)</code></pre><p>The brute-force looping einsum, <code>xs</code> is a tuple of input tensors.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einsumexp.jl#LL7-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.einsumopt-Union{Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs,iy},Any}} where iy where ixs" href="#OMEinsum.einsumopt-Union{Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs,iy},Any}} where iy where ixs"><code>OMEinsum.einsumopt</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">einsumopt(::EinCode{ixs, iy}, xs) where {ixs, iy}</code></pre><p>returns the result of the einsum operation implied by <code>ixs</code>, <code>iy</code> but evaluated in the optimal order according to <code>meinsumcost</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einsumopt.jl#LL1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.Diag" href="#OMEinsum.Diag"><code>OMEinsum.Diag</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Diag{N,T}</code></pre><p>is a type that represents a (generalized) diagonal of <code>N</code> edges of type <code>T</code> of one tensor which are stored in its <code>edges</code> field, e.g. <code>&#39;iij -&gt; ij&#39;</code> is represented by <code>Diag{1}((i,))</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL69-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.EinsumOp" href="#OMEinsum.EinsumOp"><code>OMEinsum.EinsumOp</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">EinsumOp{N}</code></pre><p>abstract supertype of all einsum operations involving <code>N</code> edges or <code>N</code> tensors (for <code>OuterProduct{N}</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL16-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.Fallback" href="#OMEinsum.Fallback"><code>OMEinsum.Fallback</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Fallback{N,T}</code></pre><p>is a type that represents an <code>einsum</code> resulting in <code>N</code> indices of type <code>T</code>, which are stored in its <code>iy</code> field. It&#39;s used as a general fallback if no more efficient method is available.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL117-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.IndexGroup" href="#OMEinsum.IndexGroup"><code>OMEinsum.IndexGroup</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IndexGroup</code></pre><p>Leaf in a contractiontree, contains the indices and the number of the tensor it describes, e.g. in &quot;ij,jk -&gt; ik&quot;, indices &quot;ik&quot; belong to tensor <code>1</code>, so would be described by IndexGroup([&#39;i&#39;,&#39;k&#39;], 1).</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einsequence.jl#LL85-L90">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.IndexReduction" href="#OMEinsum.IndexReduction"><code>OMEinsum.IndexReduction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IndexReduction{N,T}</code></pre><p>is a type that represents an index reduction of <code>N</code> edges/indices of type <code>T</code> which are stored in its <code>edges</code> field, e.g. <code>&#39;ij -&gt; i&#39;</code> is represented by <code>IndexReduction{1,Char}((j,))</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL90-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.MixedDiag" href="#OMEinsum.MixedDiag"><code>OMEinsum.MixedDiag</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MixedDiag{N,T}</code></pre><p>is a type that represents a (generalized) mixed diagonal of <code>N</code> edges of type <code>T</code> of more than one tensor which are stored in its <code>edges</code> field,  e.g. <code>&#39;iij, ik -&gt; ijk&#39;</code> is represented by <code>MixedDiag{1,Char}((i,))</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL79-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.MixedStarContract" href="#OMEinsum.MixedStarContract"><code>OMEinsum.MixedStarContract</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MixedStarContract{N,T}</code></pre><p>is a type that represents a mixed star-contraction of <code>N</code> edges of type <code>T</code> which are stored in its <code>edges</code> field. A <code>MixedStarContract{N}</code> results from <code>N</code> tensors sharing at least one index and at least one tensor has duplicate shared indices, e.g. <code>&#39;ij,ik,iil -&gt; jkl&#39;</code> is represented by <code>MixedStarContract{1,Char}((i,))</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL57-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.NestedEinsum" href="#OMEinsum.NestedEinsum"><code>OMEinsum.NestedEinsum</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NestedEinsum</code></pre><p>describes a (potentially) nested einsum. Important fields:</p><ul><li><code>args</code>, vector of all inputs, either <code>IndexGroup</code> objects corresponding to tensors or <code>NestedEinsum</code></li><li><code>iy</code>, indices of output</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einsequence.jl#LL99-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.NestedEinsum-Tuple" href="#OMEinsum.NestedEinsum-Tuple"><code>OMEinsum.NestedEinsum</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>apply a NestedEinsum to arguments evaluates the nested einsum</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einsequence.jl#LL113-L115">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.OuterProduct" href="#OMEinsum.OuterProduct"><code>OMEinsum.OuterProduct</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OuterProduct{N}</code></pre><p>is a type that represents an outer product of <code>N</code> tensors.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL110-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.Permutation" href="#OMEinsum.Permutation"><code>OMEinsum.Permutation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Permutation{N,T}</code></pre><p>is a type that represents a permutation of <code>N</code> indices which are stored in its <code>perm</code> field as a tuple of <code>N</code> integers of type <code>T</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL100-L106">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.StarContract" href="#OMEinsum.StarContract"><code>OMEinsum.StarContract</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StarContract{N,T}</code></pre><p>is a type that represents a star-contraction of <code>N</code> edges of type <code>T</code> which are stored in its <code>edges</code> field. A <code>StarContract{N}</code> results from <code>N</code> tensors sharing at least one index but <em>no</em> tensor has duplicate shared indices, e.g. <code>&#39;ij,ik,il -&gt; jkl&#39;</code> is represented by <code>StarContract{1,Char}((i,))</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL45-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.TensorContract" href="#OMEinsum.TensorContract"><code>OMEinsum.TensorContract</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TensorContract{N,T}</code></pre><p>is a type that represents a tensorcontraction of <code>N</code> edges of type <code>T</code> which are stored in its <code>edges</code> field, e.g. <code>&#39;ij,jk -&gt; ik&#39;</code> is represented by <code>TensorContract{1,Char}((j,))</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL25-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.Trace" href="#OMEinsum.Trace"><code>OMEinsum.Trace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Trace{N,T}</code></pre><p>is a type that represents a trace operation of <code>N</code> edges of type <code>T</code>, i.e. 2<code>N</code> indices, which are stored in its <code>edges</code> field, e.g. <code>&#39;ijjk -&gt; ik&#39;</code> is represented by <code>Trace{1,Char}((j,))</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL35-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.allunique-Tuple{Tuple{Vararg{T,N}} where T where N}" href="#OMEinsum.allunique-Tuple{Tuple{Vararg{T,N}} where T where N}"><code>OMEinsum.allunique</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">allunique(ix)</code></pre><p>return true if all elements of <code>ix</code> appear only once in <code>ix</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/utils.jl#LL25-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.bpcheck-Tuple{Any,Vararg{Any,N} where N}" href="#OMEinsum.bpcheck-Tuple{Any,Vararg{Any,N} where N}"><code>OMEinsum.bpcheck</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bpcheck(f, args...; η = 1e-5, verbose=false)</code></pre><p>returns a <code>Bool</code> indicating whether Zygote calculates the gradient of <code>f(args...) -&gt; scalar</code> correctly using the relation <code>f(x - ηg) ≈ f(x) - η|g|²</code>. If <code>verbose=true</code>, print <code>f(x) - f(x - ηg)</code>and <code>η|g|²</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/autodiff.jl#LL27-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.combineops-Union{Tuple{S}, Tuple{T}, Tuple{T,S}} where S&lt;:OMEinsum.EinsumOp where T&lt;:OMEinsum.EinsumOp" href="#OMEinsum.combineops-Union{Tuple{S}, Tuple{T}, Tuple{T,S}} where S&lt;:OMEinsum.EinsumOp where T&lt;:OMEinsum.EinsumOp"><code>OMEinsum.combineops</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">combineops(op1, op2)</code></pre><p>return an operator that combines the operations of <code>op1</code> and <code>op2</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL160-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.edgesfrominds-Tuple{Any,Any}" href="#OMEinsum.edgesfrominds-Tuple{Any,Any}"><code>OMEinsum.edgesfrominds</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">edgesfrominds(ixs,iy)</code></pre><p>return the edges of the ixs that imply an operation e.g. in ixs = ((1,2),(2,3)), iy = (1,3), edge 2 requires a tensor contraction</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL3-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.einsum_grad-Union{Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs,iy},Any,Any,Any,Any}} where iy where ixs" href="#OMEinsum.einsum_grad-Union{Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs,iy},Any,Any,Any,Any}} where iy where ixs"><code>OMEinsum.einsum_grad</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">einsum_grad(ixs, xs, iy, y, i)</code></pre><p>return gradient w.r.t the <code>i</code>th tensor in <code>xs</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/autodiff.jl#LL3-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.einsumcost-Tuple{Any,Any,Any}" href="#OMEinsum.einsumcost-Tuple{Any,Any,Any}"><code>OMEinsum.einsumcost</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">einsumcost(ixs, sxs, ops)</code></pre><p>returns the cost of evaluating the einsum of <code>ixs</code>, <code>sxs</code> according to the sequence in ops, where <code>sxs</code> is a tuple of sizes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL308-L314">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.evaluate-Tuple{OMEinsum.EinsumOp,Any,Any}" href="#OMEinsum.evaluate-Tuple{OMEinsum.EinsumOp,Any,Any}"><code>OMEinsum.evaluate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">evaluate(op::EinsumOp, allixs, allxs)</code></pre><p>returns a tuple of xs and ixs that result from the evaluation of the operator <code>op</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einevaluate.jl#LL11-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.evaluateall-NTuple{4,Any}" href="#OMEinsum.evaluateall-NTuple{4,Any}"><code>OMEinsum.evaluateall</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">evaluateall(ixs, xs, ops,iy)</code></pre><p>evaluate the einsum specified by &#39;ixs -&gt; iy&#39; by going through all operations in <code>ops</code> in order.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einevaluate.jl#LL1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.extractixs-Tuple{OMEinsum.IndexGroup}" href="#OMEinsum.extractixs-Tuple{OMEinsum.IndexGroup}"><code>OMEinsum.extractixs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>extract the indices of the tensor that is associated with x (if x isa IndexGroup) or results from x (if x isa NestedEinsum)</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einsequence.jl#LL122-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.extractxs-Tuple{Any,OMEinsum.NestedEinsum}" href="#OMEinsum.extractxs-Tuple{Any,OMEinsum.NestedEinsum}"><code>OMEinsum.extractxs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>extract the tensor associated with x (if x isa IndexGroup) or evaluate and return the tensor associated with x (if x isa NestedEinsum)</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einsequence.jl#LL129-L132">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.filliys!-Tuple{Any}" href="#OMEinsum.filliys!-Tuple{Any}"><code>OMEinsum.filliys!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">filliys!(neinsum::NestedEinsum)</code></pre><p>goes through all <code>NestedEinsum</code> objects in the tree and saves the correct <code>iy</code> in them.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einsequence.jl#LL65-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.get_size_dict-Union{Tuple{X}, Tuple{T}, Tuple{N}, Tuple{Tuple{Vararg{Tuple{Vararg{T,M}} where M,N}},Tuple{Vararg{AbstractArray,X}}}} where X where T where N" href="#OMEinsum.get_size_dict-Union{Tuple{X}, Tuple{T}, Tuple{N}, Tuple{Tuple{Vararg{Tuple{Vararg{T,M}} where M,N}},Tuple{Vararg{AbstractArray,X}}}} where X where T where N"><code>OMEinsum.get_size_dict</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>get the dictionary of <code>index=&gt;size</code>, error if there are conflicts</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/interfaces.jl#LL41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.index_map-Tuple{CartesianIndex,Tuple}" href="#OMEinsum.index_map-Tuple{CartesianIndex,Tuple}"><code>OMEinsum.index_map</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>take an index subset from <code>ind</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einsumexp.jl#LL66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.indicesafteroperation-Tuple{OMEinsum.EinsumOp,Any}" href="#OMEinsum.indicesafteroperation-Tuple{OMEinsum.EinsumOp,Any}"><code>OMEinsum.indicesafteroperation</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">indicesafteroperation(op, allixs)</code></pre><p>returns all indices of tensors after operation <code>op</code> was applied.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL293-L297">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.iscombineable-Union{Tuple{S}, Tuple{T}, Tuple{T,S}} where S&lt;:OMEinsum.EinsumOp where T&lt;:OMEinsum.EinsumOp" href="#OMEinsum.iscombineable-Union{Tuple{S}, Tuple{T}, Tuple{T,S}} where S&lt;:OMEinsum.EinsumOp where T&lt;:OMEinsum.EinsumOp"><code>OMEinsum.iscombineable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">iscombineable(a,b)</code></pre><p>return <code>true</code> if <code>EinsumOp</code>s <code>a</code> and <code>b</code> can be combined into one operator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL154-L158">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.loop!-Union{Tuple{T}, Tuple{N}, Tuple{Tuple{Vararg{Any,N}},Tuple{Vararg{AbstractArray,N}},Any,AbstractArray{T,N} where N,CartesianIndices,CartesianIndices}} where T where N" href="#OMEinsum.loop!-Union{Tuple{T}, Tuple{N}, Tuple{Tuple{Vararg{Any,N}},Tuple{Vararg{AbstractArray,N}},Any,AbstractArray{T,N} where N,CartesianIndices,CartesianIndices}} where T where N"><code>OMEinsum.loop!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>loop and accumulate products to y, the CPU version.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einsumexp.jl#LL51-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.map_prod-Union{Tuple{T}, Tuple{N}, Tuple{Type{T},Tuple,CartesianIndex,Tuple{Vararg{Any,N}}}} where T where N" href="#OMEinsum.map_prod-Union{Tuple{T}, Tuple{N}, Tuple{Type{T},Tuple,CartesianIndex,Tuple{Vararg{Any,N}}}} where T where N"><code>OMEinsum.map_prod</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>indiex tensors, and return the product of elements</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einsumexp.jl#LL43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.match_rule-Tuple{Any,Any}" href="#OMEinsum.match_rule-Tuple{Any,Any}"><code>OMEinsum.match_rule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Find the matched rule.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/EinRule.jl#LL98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.match_rule-Tuple{Type{OMEinsum.Hadamard},Any,Any}" href="#OMEinsum.match_rule-Tuple{Type{OMEinsum.Hadamard},Any,Any}"><code>OMEinsum.match_rule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Hadamard</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/EinRule.jl#LL51-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.match_rule-Tuple{Type{OMEinsum.PTrace},Any,Any}" href="#OMEinsum.match_rule-Tuple{Type{OMEinsum.PTrace},Any,Any}"><code>OMEinsum.match_rule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Ptrace rule if all indices of one ix in ixs all appear in iy or appear twice and don&#39;t appear in iy</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/EinRule.jl#LL58-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.match_rule-Tuple{Type{OMEinsum.Permutedims},Any,Any}" href="#OMEinsum.match_rule-Tuple{Type{OMEinsum.Permutedims},Any,Any}"><code>OMEinsum.match_rule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>permutation rule</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/EinRule.jl#LL41-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.match_rule-Tuple{Type{OMEinsum.Sum},Any,Any}" href="#OMEinsum.match_rule-Tuple{Type{OMEinsum.Sum},Any,Any}"><code>OMEinsum.match_rule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>a einsum code is sum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/EinRule.jl#LL32-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.match_rule-Tuple{Type{OMEinsum.Tr},Any,Any}" href="#OMEinsum.match_rule-Tuple{Type{OMEinsum.Tr},Any,Any}"><code>OMEinsum.match_rule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>a einsum code is trace</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/EinRule.jl#LL15-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.match_rule-Union{Tuple{T}, Tuple{M}, Tuple{N}, Tuple{Type{PairWise},Tuple{Vararg{Tuple{Vararg{T,X}} where X,N}},Tuple{Vararg{T,M}}}} where T where M where N" href="#OMEinsum.match_rule-Union{Tuple{T}, Tuple{M}, Tuple{N}, Tuple{Type{PairWise},Tuple{Vararg{Tuple{Vararg{T,X}} where X,N}},Tuple{Vararg{T,M}}}} where T where M where N"><code>OMEinsum.match_rule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>a einsum code is a pairwise graph.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/EinRule.jl#LL24-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.nopermute-Tuple{Tuple{Vararg{T,N}} where T where N,Tuple{Vararg{T,N}} where T where N}" href="#OMEinsum.nopermute-Tuple{Tuple{Vararg{T,N}} where T where N,Tuple{Vararg{T,N}} where T where N}"><code>OMEinsum.nopermute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">nopermute(ix,iy)</code></pre><p>check that all values in <code>iy</code> that are also in <code>ix</code> have the same relative order, e.g. <code>nopermute((1,2,3),(1,2))</code> is true while <code>nopermute((1,2,3),(2,1))</code> is false</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/utils.jl#LL7-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.opcost-Tuple{OMEinsum.EinsumOp,Any,Any,Tuple{Vararg{Tuple{Vararg{Int64,N}} where N,M}} where M}" href="#OMEinsum.opcost-Tuple{OMEinsum.EinsumOp,Any,Any,Tuple{Vararg{Tuple{Vararg{Int64,N}} where N,M}} where M}"><code>OMEinsum.opcost</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">opcost(op, ocost, allixs, allsxs)</code></pre><p>returns the cost (in number of iterations it would require in a for loop) of evaluating <code>op</code> with arguments <code>allixs</code> and <code>allsxs</code> plus <code>ocost</code> as well as the new indices and sizes after evaluation.</p><p><code>allsxs</code> is a tuple of tuples of Ints - the sizes of the respective arrays</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL244-L253">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.operatorfromedge-Tuple{Any,Any,Any}" href="#OMEinsum.operatorfromedge-Tuple{Any,Any,Any}"><code>OMEinsum.operatorfromedge</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">operatorfromedge(edge, ixs, iy)</code></pre><p>returns a subtype of <code>EinsumOp</code> which specifies the kind of operation that the reduction of <code>edge</code> corresponds to.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL127-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.operatorsfromedges-Tuple{Any,Any,Any}" href="#OMEinsum.operatorsfromedges-Tuple{Any,Any,Any}"><code>OMEinsum.operatorsfromedges</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">operatorsfromedges(ixs, sxs, edges, iy)</code></pre><p>given a list of  edges <code>edges</code>, return a list of operations where consecutive operations are combined if possible.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL171-L176">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.optimalorder-Tuple{Any,Any,Any}" href="#OMEinsum.optimalorder-Tuple{Any,Any,Any}"><code>OMEinsum.optimalorder</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">optimalorder(ixs, xs, iy)</code></pre><p>return a tuple of operations that represents the (possibly nonunique) optimal order of reduction-operations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL318-L323">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.optimiseorder-NTuple{4,Any}" href="#OMEinsum.optimiseorder-NTuple{4,Any}"><code>OMEinsum.optimiseorder</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">optimiseorder(ixs, sxs, edges, iy)</code></pre><p>return a tuple of operations that represents the (possibly nonunique) optimal order of reduction-operations in <code>ops</code> and its cost.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL329-L334">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.overlap-Tuple{Any,Any}" href="#OMEinsum.overlap-Tuple{Any,Any}"><code>OMEinsum.overlap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">overlap(s1, s2)</code></pre><p>return true if <code>s1</code> and <code>s2</code> share any element.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einorder.jl#LL285-L289">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="OMEinsum.parse_parens-Tuple{AbstractString,Any,Any}" href="#OMEinsum.parse_parens-Tuple{AbstractString,Any,Any}"><code>OMEinsum.parse_parens</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">parse_parens(s::AbstractString, i, narg)</code></pre><p>parse one level of parens starting at index <code>i</code> where <code>narg</code> counts which tensor the current group of indices, e.g. &quot;ijk&quot;, belongs to. Recursively calls itself for each new opening paren that&#39;s opened.</p></div></div><a class="source-link" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/f80d1f2beb77833fd148b0ed4bd7572b3756d0f2/src/einsequence.jl#LL18-L23">source</a></section><footer><hr/></footer></article></body></html>
